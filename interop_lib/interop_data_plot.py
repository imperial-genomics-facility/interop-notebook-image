import os,re
import numpy as np
import pandas as pd
from collections import defaultdict
import seaborn as sns
import iplotter
from scipy.stats import linregress
from IPython.display import HTML

def read_interop_data(filepath):
  """
  This function reads a dump file generated by interop_dumptext tool and returns a list of Pandas dataframe

  :param filepath: A interop dumptext output path
  :returns: A dict containing following key and value of Pandas dataframes

    * Tile
    * Q2030
    * Extraction
    * Error
    * EmpiricalPhasing
    * CorrectedInt
    * QByLane
    * ExtendedTile
    * DynamicPhasing
    * Image
    * Q
    * Index

  """
  try:
    if not os.path.exists(filepath):
      raise IOError('File {0} not found'.format(filepath))
    data = defaultdict(list)
    header = None
    data_header = None
    with open(filepath,'r') as fp:
      for line in fp:
        line = line.strip()
        if line.startswith('#'):
          if line.startswith('# Version') or \
             line.startswith('# Column Count') or \
             line.startswith('# Bin Count') or \
             line.startswith('# Channel Count'):
            pass
          else:
            header = line.strip('# ').split(',')[0]
        else:
          if header is not None:
            if 'Lane' in line.split(','):
              data_header = line.split(',')
              continue
            if data_header is not None:
              data[header].append(dict(zip(data_header, line.split(','))))
    list_of_metrix = [
        'CorrectedInt',
        'Tile',
        'Error',
        'Q2030',
        'Extraction',
        'EmpiricalPhasing',
        'QByLane',
        'ExtendedTile'
        'DynamicPhasing',
        'Image',
        'Q',
        'Index']
    output_dict = dict()
    for key in list_of_metrix:
      if data.get(key) is None:
        output_dict.update({key: pd.DataFrame()})
      else:
        output_dict.update({key: pd.DataFrame(data.get(key))})
    return output_dict
  except Exception as e:
    raise ValueError('Failed to extract data from interop dump, error:{0}'.format(e))

def read_runinfo_xml(runInfoXml_path):
  """
  A function for reading RunInfo.xml file from Illumina sequencing run and returns data as Pandas DataFrame

  :param runInfoXml_path: Filepath for RunInfo.xml
  :returns: A Pandas dataframe containing the run configuration data
  """
  try:
    if not os.path.exists(runInfoXml_path):
      raise IOError('File {0} not found'.format(runInfoXml_path))
    pattern = \
      re.compile(r'<Read Number=\"(\d)\" NumCycles=\"(\d+)\" IsIndexedRead=\"(Y|N)\"')
    read_info = list()
    with open(runInfoXml_path,'r') as fp:
      for line in fp:
        line = line.strip()
        if line.startswith('<Read Number'):
          read_info.append(line)
          read_start = 0
          reads_stat = list()
          for i in read_info:
            if re.match(pattern,i):
              read_number, numcycle, index_read = re.match(pattern,i).groups()
              reads_stat.append({
                'read_id': int(read_number),
                'cycles': int(numcycle),
                'start_cycle': int(read_start),
                'index_read': index_read})
              read_start += int(numcycle)
    reads_stat = pd.DataFrame(reads_stat)
    reads_stat['read_id'] = reads_stat['read_id'].astype(int)
    return reads_stat
  except Exception as e:
    raise ValueError('Failed to read RunInfo.xml for sequencing run, error: {0}'.format(e))

def extract_read_data_from_tileDf(tileDf):
  try:
    read_data = list()
    for read_id, r_data in tileDf.groupby('Read'):
      for lane_id, l_data in r_data.groupby('Lane'):
        read_count = l_data['ClusterCount'].astype(float).sum()
        read_count = int(read_count) / 1000000
        read_count_pf = l_data['ClusterCountPF'].astype(float).sum()
        read_count_pf = int(read_count_pf) / 1000000
        density_count = l_data['Density'].astype(float).mean()
        density_count = int(density_count) / 1000
        pct_cluster_count_pf = '{0:.2f}'.format(int(read_count_pf) / int(read_count))
        read_data.append({
          'read_id': read_id,
          'lane_id': lane_id,
          'density': '{:.2f}'.format(density_count),
          'read_count': '{:.2f}'.format(read_count),
          'read_count_pf': '{:.2f}'.format(read_count_pf),
          'cluster_pf': pct_cluster_count_pf})
    read_data = pd.DataFrame(read_data)
    read_data['read_id'] = read_data['read_id'].astype(int)
    read_data['lane_id'] = read_data['lane_id'].astype(int)
    return read_data
  except Exception as e:
    raise ValueError('Failed to extract data from TileDf, error: {0}'.format(e))

def extract_yield_data_from_q2030Df(q2030Df, runinfoDf):
  try:
    yield_data = list ()
    q2030Df['Lane'] = q2030Df['Lane'].astype(int)
    q2030Df['Cycle'] = q2030Df['Cycle'].astype(int)
    for lane_id, l_data in q2030Df.groupby('Lane'):
      for read_entry in runinfoDf.to_dict(orient='records'):
        read_id = read_entry.get('read_id')
        start_cycle = int(read_entry.get('start_cycle'))
        total_cycle = int(read_entry.get('cycles'))
        finish_cycle = start_cycle + total_cycle
        r_q30 = \
          l_data[(l_data['Cycle'] > start_cycle) & (l_data['Cycle'] < finish_cycle)]\
            ['Q30'].astype(int).fillna(0).sum()
        r_t = \
          l_data[(l_data['Cycle'] > start_cycle) & (l_data['Cycle'] < finish_cycle)]\
            ['Total'].astype(int).fillna(0).sum()
        if int(r_q30) > 0 and \
           int(r_t) > 0:
          r_pct = '{:.2f}'.format(int(r_q30) / int(r_t) * 100)
          r_yield = '{:.2f}'.format(int(r_t) / 1000000000)
        else:
          r_pct = 0
          r_yield = 0 
        yield_data.append({
          'lane_id': lane_id,
          'read_id': read_id,
          'q30_pct': r_pct,
          'yield': r_yield})
    yield_data = pd.DataFrame(yield_data)
    yield_data['read_id'] = yield_data['read_id'].astype(int)
    yield_data['lane_id'] = yield_data['lane_id'].astype(int)
    return yield_data
  except Exception as e:
    raise ValueError('Failed to extract data from q2030Df, error: {0}'.format(e))

def get_extraction_data_from_extractionDf(extractionDf, runinfoDf):
  try:
    extractionDf['Lane'] = extractionDf['Lane'].astype(int)
    extractionDf['Cycle'] = extractionDf['Cycle'].astype(int)
    for c in extractionDf.columns:
        if c.startswith('MaxIntensity_'):
            extractionDf[c] = extractionDf[c].astype(int)
    extraction_data = list()
    maxIntensity_col = [
      c for c in extractionDf.columns
        if c.startswith('MaxIntensity_')][0]
    for lane_id, l_data in extractionDf.groupby('Lane'):
      for read_entry in runinfoDf.to_dict(orient='records'):
        read_id = read_entry.get('read_id')
        start_cycle = int(read_entry.get('start_cycle')) + 1
        intensity_c1 = \
          l_data[l_data['Cycle']==start_cycle][maxIntensity_col].mean()
        if intensity_c1 == 'nan':
          intensity_c1 = 0
        intensity_c1 = '{:.2f}'.format(intensity_c1)
        extraction_data.append({
          'lane_id': lane_id,
          'read_id': read_id,
          'intensity_c1': intensity_c1})
    extraction_data = pd.DataFrame(extraction_data)
    extraction_data['lane_id'] = extraction_data['lane_id'].astype(int)
    extraction_data['read_id'] = extraction_data['read_id'].astype(int)
    return extraction_data
  except Exception as e:
    raise ValueError('Failed to get data from extractionDf, error: {0}'.format(e))

def get_data_from_errorDf(errorDf, runinfoDf):
  try:
    errorDf['Lane'] = errorDf['Lane'].astype(int)
    errorDf['Cycle'] = errorDf['Cycle'].astype(int)
    errorDf['ErrorRate'] = errorDf['ErrorRate'].astype(float)
    error_data = list()
    for lane_id, l_data in errorDf.groupby('Lane'):
      for read_entry in runinfoDf.to_dict(orient='records'):
        read_id = read_entry.get('read_id')
        start_cycle = int(read_entry.get('start_cycle'))
        total_cycle = int(read_entry.get('cycles'))
        finish_cycle = start_cycle + total_cycle
        error_cycles = \
          l_data[(l_data['Cycle'] > start_cycle) & (l_data['Cycle'] < finish_cycle)]\
            ['Cycle'].drop_duplicates().count()
        error_rate = \
          l_data[(l_data['Cycle'] > start_cycle) & (l_data['Cycle'] < finish_cycle)]\
            ['ErrorRate'].mean()
        error_rate = '{0:.3f}'.format(error_rate)
        if error_rate == 'nan':
          error_rate = 0
        error_data.append({
          'lane_id': lane_id,
          'read_id': read_id,
          'error_cycles': str(error_cycles),
          'error_rate': error_rate})
    if len(error_data) == 0:
      error_data = \
        pd.DataFrame(columns=['lane_id','read_id','error_cycles','error_rate'])
    else:
      error_data = pd.DataFrame(error_data)
    error_data['lane_id'] = error_data['lane_id'].astype(int)
    error_data['read_id'] = error_data['read_id'].astype(int)
    return error_data
  except Exception as e:
    raise ValueError('Failed to get data from errorDf, error: {0}'.format(e))

def calculate_phasing_stats(empiricalPhasingDf, runinfoDf):
  try:
    for i in ('Lane', 'Cycle', 'Tile', 'Phasing', 'Prephasing'):
      if i not in empiricalPhasingDf.columns:
        raise KeyError('Missing key {0} in empiricalPhasingDf'.format(i))

    empiricalPhasingDf['Lane'] = empiricalPhasingDf['Lane'].astype(int)
    empiricalPhasingDf['Cycle'] = empiricalPhasingDf['Cycle'].astype(int)
    empiricalPhasingDf['Tile'] = empiricalPhasingDf['Tile'].astype(int)
    empiricalPhasingDf['Phasing'] = empiricalPhasingDf['Phasing'].astype(float)
    empiricalPhasingDf['Prephasing'] = empiricalPhasingDf['Prephasing'].astype(float)
    data = list()
    for lane_id, l_data in empiricalPhasingDf.groupby('Lane'):
      for read_entry in runinfoDf.to_dict(orient='records'):
        read_id = read_entry.get('read_id')
        index_read = read_entry.get('index_read')
        start_cycle = int(read_entry.get('start_cycle'))
        total_cycle = int(read_entry.get('cycles'))
        finish_cycle = start_cycle + total_cycle
        phasing_scores = \
          list(l_data[(l_data['Cycle'] > start_cycle+1) & (l_data['Cycle'] < finish_cycle)].\
            groupby('Cycle')['Phasing'].agg('median'))
        prephasing_scores = \
          list(l_data[(l_data['Cycle'] > start_cycle+1) & (l_data['Cycle'] < finish_cycle)].\
            groupby('Cycle')['Prephasing'].agg('median'))
        if index_read == 'N' and \
           len(phasing_scores) > 0 and \
           len(prephasing_scores) > 0:
          linreg_phasing = \
            linregress(range(1,len(phasing_scores) + 1), phasing_scores)
          linreg_prephasing = \
            linregress(range(1, len(prephasing_scores) + 1), prephasing_scores)
          data.append({
              'lane_id': lane_id,
              'read_id': read_id,
              'phasing_slope': '{0:.3f}'.format(linreg_phasing.slope),
              'phasing_offset': '{0:.3f}'.format(linreg_phasing.intercept),
              'prephasing_slope': '{0:.3f}'.format(linreg_prephasing.slope),
              'prephasing_offset': '{0:.3f}'.format(linreg_prephasing.intercept),
          })
        else:
          data.append({
              'lane_id': lane_id,
              'read_id': read_id,
              'phasing_slope': 0,
              'phasing_offset': 0,
              'prephasing_slope': 0,
              'prephasing_offset': 0,
          })
    data = pd.DataFrame(data)
    return data
  except Exception as e:
    raise ValueError('Failed to get phasing stats, error: {0}'.format(e))

def get_summary_stats(tileDf, q2030Df, extractionDf, errorDf, empiricalPhasingDf, runinfoDf):
  try:
    read_data = \
      extract_read_data_from_tileDf(tileDf=tileDf)
    yield_data = \
      extract_yield_data_from_q2030Df(
        q2030Df=q2030Df,
        runinfoDf=runinfoDf)
    extraction_data = \
      get_extraction_data_from_extractionDf(
        extractionDf=extractionDf,
        runinfoDf=runinfoDf)
    phasing_data = \
      calculate_phasing_stats(
        empiricalPhasingDf=empiricalPhasingDf,
        runinfoDf=runinfoDf)
    merged_data = \
      yield_data.\
        merge(read_data, how='left', on=['read_id', 'lane_id']).\
        merge(runinfoDf, how='left', on='read_id').\
        merge(extraction_data, how='left', on=['lane_id', 'read_id']).\
        merge(phasing_data, how='left', on=['lane_id', 'read_id']).\
        fillna(0)
    if errorDf is not None and \
       len(errorDf.index) > 0:
      error_data = \
        get_data_from_errorDf(
          errorDf=errorDf,
          runinfoDf=runinfoDf)
      merged_data = \
        merged_data.\
          merge(error_data, how='left', on=['lane_id', 'read_id']).\
          fillna(0)
    return merged_data
  except Exception as e:
    raise ValueError('Failed to get summary stats, error: {0}'.format(e))

def plot_intensity_data(extractionDf, color_palette='colorblind', width=1000, height=600):
    try:
        intensity_columns = [
            c for c in extractionDf.columns
                if c.startswith('MaxIntensity_')]
        if len(intensity_columns) == 0:
            raise ValueError('No intensity columns found')
        extractionDf['Lane'] = extractionDf['Lane'].astype(int)
        extractionDf['Cycle'] = extractionDf['Cycle'].astype(int)
        for c in intensity_columns:
            extractionDf[c] = extractionDf[c].astype(float)
        formatted_data = list()
        for lane_id, l_data in extractionDf.groupby('Lane'):
            for cycle, c_data in l_data.groupby('Cycle'):
                row = {'Lane':lane_id, 'Cycle':cycle}
                for c in intensity_columns:
                    row.update({c: c_data[c].median()})
                formatted_data.append(row)
        formatted_data = pd.DataFrame(formatted_data)
        plots = list()
        colors = sns.color_palette(color_palette, len(intensity_columns), as_cmap=False).as_hex()
        chart_js = iplotter.ChartJSPlotter()
        for lane_id, l_data in formatted_data.groupby('Lane'):
            labels = l_data.sort_values('Cycle').set_index('Cycle').index
            datasets = list()
            for c, color in zip(intensity_columns, colors):
                intensity_data = l_data.sort_values('Cycle').set_index('Cycle')[c].values
                datasets.append({
                    "label": c,
                    "data": list(intensity_data),
                    "type": "line",
                    "fill": False,
                    "pointBorderColor": "transparent",
                    "backgroundColor": color,
                    "borderColor": color,
                    "lineTension": 0})
            data_json = {
                "datasets":datasets,
                "labels": list(labels)}
            options = {
                "animation": {
                    "duration": 0
                },
                "title": {
                    "display": True,
                    "text": 'Intensity plots for lane {0}'.format(lane_id),
                    "fontSize":16
                },
                "scales": {
                    "yAxes":[{
                        "scaleLabel":{
                            "display":True,
                            "labelString":"Intensity values"
                        }
                    }],
                    "xAxes":[{
                        "scaleLabel":{
                            "display":True,
                            "labelString":"Cycles"
                        }
                    }]
                }
            }
            plot = chart_js.plot(data_json, options=options, chart_type="line", w=width, h=height)
            plots.append(plot)
        return plots
    except Exception as e:
        raise ValueError(e)

def get_box_plots(tilesDf,color_palette='colorblind',width=800,height=600):
  """
  A function for plotting Boxplot for the entries from interop data
  
  :param tilesDf: A Pandas dataframe containing the Tiles data
  :param color_palette: Seaborn color palette name, default 'colorblind'
  :param width: Plot width, default 800
  :param height: Plot height, default 600
  :returns: A list of IPythondisplay.HTML objects containing the following boxplots

  * ClusterCount
  * Density

  """
  try:
    if not isinstance(tilesDf, pd.DataFrame):
      raise TypeError('Expecting a Pandas.DataFrame and got : {0}'.format(type(tilesDf)))
    if 'ClusterCountPF' not in tilesDf or \
       'ClusterCount' not in tilesDf or \
       'Density' not in tilesDf or \
       'DensityPF' not in tilesDf:
      raise KeyError('Missing required key for box plots')
    colors = \
      sns.color_palette(
        color_palette,
        len(tilesDf.groupby('Lane').groups.keys()),
        as_cmap=False).as_hex()
    tilesDf.dropna(inplace=True)
    tilesDf['ClusterCountPF'] = tilesDf['ClusterCountPF'].astype(float)
    tilesDf['ClusterCount'] = tilesDf['ClusterCount'].astype(float)
    tilesDf['Density'] = tilesDf['Density'].astype(float)
    tilesDf['DensityPF'] = tilesDf['DensityPF'].astype(float)
    tilesDf['Lane'] = tilesDf['Lane'].astype(int)
    clusterCount_box_data = list()
    density_box_data = list()
    for lane_id,l_data in tilesDf.groupby('Lane'):
      clusterCount_box_data.extend([{
        "y": list(l_data['ClusterCount'].values),
        "type": 'box',
        "name": 'Lane {0}'.format(lane_id),
        "marker": {
          "color": colors[lane_id - 1]
        },
        "boxpoints": 'Outliers'
      },{
        "y":list(l_data['ClusterCountPF'].values),
        "type": 'box',
        "name": 'Lane {0}'.format(lane_id),
        "marker": {
          "color": colors[lane_id - 1]
        },
        "boxpoints": 'Outliers'
      }])
      density_box_data.extend([{
        "y": list(l_data['Density'].values),
        "type": 'box',
        "name": 'Lane {0}'.format(lane_id),
        "marker": {
          "color": colors[lane_id-1]
        },
        "boxpoints": 'Outliers'
      },{
        "y": list(l_data['DensityPF'].values),
        "type": 'box',
        "name": 'Lane {0}'.format(lane_id),
        "marker": {
          "color": colors[lane_id-1]
        },
        "boxpoints": 'Outliers'
      }])
    clusterCount_layout = {
      "title": 'ClusterCount'
    }
    density_layout = {
      "title": 'Density'
    }
    clusterCount_plotter = iplotter.PlotlyPlotter()
    density_plotter = iplotter.PlotlyPlotter()
    return clusterCount_plotter.plot(clusterCount_box_data, layout=clusterCount_layout, w=width, h=height),\
           density_plotter.plot(density_box_data, layout=density_layout, w=width, h=height)
  except Exception as e:
    raise ValueError('Failed to prepare data for boxplots, error: {0}'.format(e))

def get_qscore_distribution_plots(qByLaneDf, color_palette='colorblind', width=800, height=400):
  try:
    key_cols = [c for c in qByLaneDf.columns if c.startswith('Bin_')]
    if not isinstance(qByLaneDf, pd.DataFrame):
      raise TypeError('Expecting a Pandas DataFrame and got {0}'.format(type(qByLaneDf)))
    qByLaneDf.fillna(0,inplace=True)
    qByLane_filt = \
      qByLaneDf[qByLaneDf['Lane'].\
        isin(['0', '1', '2', '3', '4', '5', '6', '7', '8'])].copy()
    qByLane_filt = qByLane_filt.applymap(lambda x: int(x))
    colors = \
      sns.color_palette(
        color_palette,
        len(qByLane_filt.groupby('Lane').groups.keys()),
        as_cmap=False).as_hex()
    max_q30_line = \
      int(qByLane_filt.groupby('Lane').agg('mean')[key_cols[-1]].max()) + 10000
    qscore_dist_data = list()
    for lane_id, l_data in qByLane_filt.groupby('Lane'):
      lane_id = int(lane_id)
      qscore_dist_data.append({
        "label": 'Lane {0}'.format(lane_id),
        "data": list(l_data[key_cols].mean().values),
        "backgroundColor": colors[lane_id - 1]
      })
    qscore_dist_data.append({
      "type": "line",
      "data": [
        {"y": None},
        {"y": None},
        {"y": None},
        {"y": None},
        {"y": max_q30_line},
        {"y": max_q30_line},
        {"y": max_q30_line}],
      "backgroundColor": "rgba(54, 162, 235, 0.3)",
      "borderColor": "transparent",
      "pointBorderColor": "transparent",
      "pointBackgroundColor": "transparent",
      "legend": { "display": False },
      "fill": '-1',
      "label": "Q30"
    })
    data = {
      "datasets": qscore_dist_data,
      "labels": key_cols
    }
    options = {
      "animation": {
        "duration": 0
      },
      "legend": {
        "display": True
      },
      "title": {
        "display": True,
        "text": 'QScore distribution plot',
        "fontSize":16
        },
        "scales": {
          "yAxes": [{
            "scaleLabel": {
              "display": True,
              "labelString": "Mean score values"
            }
          }],
          "xAxes": [{
            "scaleLabel": {
              "display": True,
              "labelString": "Lanes"
            }
          }]
        }
    }
    chart_js = iplotter.ChartJSPlotter()
    return chart_js.plot(data, options=options, chart_type="bar", w=width, h=height)
  except Exception as e:
    raise ValueError('Failed to get qscore plot, error: {0}'.format(e))

def get_qscore_bar_plots(q2030Df, color_palette='colorblind', width=1000, height=400):
  try:
    if not isinstance(q2030Df,pd.DataFrame):
      raise TypeError('Expecting a Pandas Dataframe and got {0}'.format(type(q2030Df)))
    for i in ('Lane', 'Tile', 'Cycle', 'MedianQScore'):
      if i not in q2030Df.columns:
        raise KeyError('Missing key column {0} in Q2030 df'.format(i))
    q2030Df['Lane'] = q2030Df['Lane'].astype(int)
    q2030Df['Cycle'] = q2030Df['Cycle'].astype(int)
    q2030Df['MedianQScore'] = q2030Df['MedianQScore'].astype(int)
    q2030Df['MedianQScore'] = \
      np.where(q2030Df['MedianQScore'] > 50, 0, q2030Df['MedianQScore'])
    q2030Df['Tile'] = q2030Df['Tile'].astype(int)
    qscore_bar_plots = list()
    colors = \
      sns.color_palette(
        color_palette,
        len(q2030Df.groupby('Lane').groups.keys()),
        as_cmap=False).as_hex()
    for lane_id, l_data in q2030Df.groupby('Lane'):
      lane_id = int(lane_id)
      dataset = list(l_data.groupby('Cycle')['MedianQScore'].mean().values)
      dataset = [int(i) for i in dataset]
      labels = list(l_data.groupby('Cycle')['MedianQScore'].mean().index)
      data = {
        "datasets": [{
          "label": 'Lane {0}'.format(lane_id),
          "data": dataset,
          "backgroundColor": colors[lane_id - 1],
        }],
        "labels": labels
      }
      options = {
      "animation": {
        "duration": 0
      },
      "title": {
        "display": True,
        "text": 'QScore distribution bar plot lane {0}'.format(lane_id),
        "fontSize": 16
        },
        "scales": {
          "yAxes": [{
            "ticks": {
              "min": 0,
              "max": 45,
            },
            "scaleLabel": {
              "display": True,
              "labelString": "Mean QScore value"
            }
          }],
          "xAxes": [{
            "scaleLabel": {
              "display": True,
              "labelString": "Cycles"
            }
          }]
        }
    }
      chart_js = iplotter.ChartJSPlotter()
      qscore_bar_plots.append(chart_js.plot(data, options=options, chart_type="bar", w=width, h=height))
    return qscore_bar_plots
  except Exception as e:
    raise ValueError('Failed to get qscore heatmap, error: {0}'.format(e))

def color_report_table(
      s, q30_column='Q30 pct', q30_threshold=90,
      cluster_pf_column='Cluster pf', cluster_pf_threshold=0.65,
      index_read_column='Index read',good_color='green',bad_color='red'):
  try:
    color_list = list()
    if q30_column not in list(s.keys()) or \
       cluster_pf_column not in list(s.keys()):
      raise KeyError('target columns not found in series {0}'.format(s.keys()))
    for c in list(s.keys()):
      if c == q30_column and \
         s[index_read_column]=='N':
        if float(s[c]) >= float(q30_threshold):
          color_list.append('color:{0}'.format(good_color))
        else:
          color_list.append('color:{0}'.format(bad_color))
      elif c == cluster_pf_column and \
           s[index_read_column]=='N':
        if float(s[c]) >= float(cluster_pf_threshold):
          color_list.append('color:{0}'.format(good_color))
        else:
          color_list.append('color:{0}'.format(bad_color))
      else:
        color_list.append('')
    return color_list
  except Exception as e:
    raise ValueError('Failed to color target columns, error: {0}'.format(e))

def get_flowcell_plot(tileDf, key='ClusterCountPF', surface_cutoff=2000, width=1000, height=500):
  try:
    if not isinstance(tileDf, pd.DataFrame):
      raise TypeError('Expecting a Pandas dataframe, got {0}'.format(type(tileDf)))

    for i in ('Lane', 'Tile', key):
      if i not in tileDf.columns:
        raise KeyError('Missing key {0} in tileDf'.format(i))

    surface1_zdata = list()
    surface2_zdata = list()
    tileDf_filt = tileDf[tileDf['Lane']!=''].copy()
    tileDf_filt['Lane'] = tileDf_filt['Lane'].astype(int)
    tileDf_filt['Tile'] = tileDf_filt['Tile'].astype(int)
    tileDf_filt[key] = tileDf_filt[key].astype(float)
    if surface_cutoff == 2000:
      tiles_count_le_2k = \
        len([i for i in tileDf_filt.groupby('Tile').groups.keys() if int(i) < 2000])
      if tiles_count_le_2k == 0:
        surface_cutoff = 2200                                                   # reset surface cutoff
    lanes = list()
    for lane_id,l_data in tileDf_filt.groupby('Lane'):
      lanes.append('Lane {0}'.format(lane_id))
      surface1_zdata.append(
        list(l_data[l_data['Tile'] < surface_cutoff].\
          groupby('Tile')[key].agg('median').values))
      surface2_zdata.append(
        list(l_data[l_data['Tile'] >= surface_cutoff].\
          groupby('Tile')[key].agg('median').values))
    surface1_tiles = \
      list(tileDf_filt[(tileDf_filt['Lane']==lane_id) & (tileDf_filt['Tile'] < surface_cutoff)].\
          groupby('Tile').groups.keys())
    surface2_tiles = \
      list(tileDf_filt[(tileDf_filt['Lane']==lane_id) & (tileDf_filt['Tile'] >= surface_cutoff)].\
          groupby('Tile').groups.keys())
    surface1_tiles = [
      'Tile {0}'.format(t)
        for t in surface1_tiles
          if int(t) < surface_cutoff]
    surface2_tiles = [
      'Tile {0}'.format(t)
        for t in surface2_tiles
          if int(t) >= surface_cutoff]
    surface1_data = [{
      "z": surface1_zdata,
      "x": surface1_tiles,
      "y": lanes,
      "type": 'heatmap',
      "colorscale": 'Viridis'
    }]
    surface2_data = [{
      "z": surface2_zdata,
      "x": surface2_tiles,
      "y": lanes,
      "type": 'heatmap',
      "colorscale": 'Viridis'
    }]
    surface1_layout = {
      "title": 'Flowcell surface 1 heatmap - {0}'.format(key),
      "xaxis": {
        "side": 'bottom',
        "title": "Tiles",
        "tickson": 'boundaries'},
      "yaxis": {
        "autosize": False,
        "title": "Lanes",
        "width": width,
        "height": height,
        "tickson": 'boundaries'
      }
    }
    surface2_layout = {
      "title": 'Flowcell surface 2 heatmap - {0}'.format(key),
      "xaxis": {
        "side": 'bottom',
        "title": "Tiles",
        "tickson": 'boundaries'},
      "yaxis": {
        "autosize": False,
        "title": "Lanes",
        "width": width,
        "height": height,
        "tickson": 'boundaries'
      }
    }
    surface1_plotter = iplotter.PlotlyPlotter()
    surface2_plotter = iplotter.PlotlyPlotter()
    return surface1_plotter.plot(surface1_data, layout=surface1_layout, w=width, h=height),\
           surface2_plotter.plot(surface2_data, layout=surface2_layout, w=width, h=height)
  except Exception as e:
    raise ValueError('Failed to plot flowcell data, error: {0}'.format(e))

def summary_report_and_plots_for_interop_dump(interop_dump, runInfoXml_path):
  """
  A function for Interop report and plots generation

  :params interop_dump: Path to interop dump file generated using the interop_dumptext tool
  :params runInfoXml_path: Path to RunInfo.xml file for Illumina run
  :returns: Returns the following

    * merged_data_html: HTML formatted summary table
    * intensity_plots: A list of line plots for intensity data
    * clusterCount_plot: Box plot for ClusterCount and ClusterCountPF data
    * density_plot: Box plot for Density and DensityPF data
    * qscore_distribution_plot: Mean QScore distribution for all lanes for individual bins
    * qscore_bar_plots: Mean QScore distribution per cycle for individual lanes
    * f_surface1: Heatmap plot of flowcell surface 1
    * f_surface2: Heatmap plot of flowcell surface 2

  """
  try:
    data = \
      read_interop_data(filepath=interop_dump)
    runinfoDf = read_runinfo_xml(runInfoXml_path)
    merged_data = \
      get_summary_stats(
        tileDf=data.get('Tile'),
        q2030Df=data.get('Q2030'),
        extractionDf=data.get('Extraction'),
        empiricalPhasingDf=data.get('EmpiricalPhasing'),
        errorDf=data.get('Error'),
        runinfoDf=runinfoDf)
    merged_data.columns = [c.capitalize().replace("_"," ") for c in merged_data.columns]
    merged_data_html = \
      HTML(
        merged_data.style.apply(
          lambda s: \
            color_report_table(
              s=s,
              q30_column='Q30 pct',
              q30_threshold=90,
              cluster_pf_column='Cluster pf',
              cluster_pf_threshold=0.65,
              index_read_column='Index read',
              good_color='green',
              bad_color='red'),
          axis=1,).\
        hide_index().render())
    intensity_plots = \
      plot_intensity_data(extractionDf=data.get('Extraction'))
    (f_surface1,f_surface2) = \
      get_flowcell_plot(tileDf=data.get('Tile'))
    (clusterCount_plot,density_plot) = \
      get_box_plots(tilesDf=data.get('Tile'))
    qscore_distribution_plot = \
      get_qscore_distribution_plots(qByLaneDf=data.get('QByLane'))
    qscore_bar_plots = \
      get_qscore_bar_plots(q2030Df=data.get('Q2030'))
    return merged_data_html, intensity_plots, clusterCount_plot, density_plot,\
           qscore_distribution_plot, qscore_bar_plots, f_surface1, f_surface2
  except Exception as e:
    raise ValueError('Failed to get report and plots for interop, error: {0}'.format(e))

